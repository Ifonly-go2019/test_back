<form method="post" action="list.aspx" id="ctl00">
<div class="aspNetHidden">
<input type="hidden" name="__VIEWSTATE" id="__VIEWSTATE" value="" />
</div>
<div>
	<table cellspacing="0" rules="all" border="1" id="GVForExport" style="border-collapse:collapse;">
		<tr>
			<th scope="col">自定义题号</th><th scope="col">题目难度</th><th scope="col">所属阶段</th><th scope="col">知识点</th><th scope="col">题目名称</th><th scope="col">题目描述</th><th scope="col">答案</th><th scope="col">答案描述</th><th scope="col">备注</th>
		</tr><tr>
			<td>yjw-2-06-p</td><td>
                         普通
                    </td><td>
                         阶段二
                    </td><td>
                     链表 
                    </td><td>写出结果：阅读算法，并回答下列问题</td><td>
                     LinkList &nbsp;*Demo(LinkList *L){ &nbsp;// L是无头结点的单链表LinkList*q,*p;if(L&amp;&amp;L-&gt;next){ &nbsp;q=L;L=L-&gt;next;p=L;while (p-&gt;next) &nbsp; &nbsp; &nbsp;{p=p-&gt;next;} p-&gt;next=q; q-&gt;next=NULL;} &nbsp;return(L);}问题1：while语句执行完毕后，p指针指向哪个结点?问题2：算法执行完毕后，返回值为原链表的哪个结点?问题3：简述该算法的主要功能。
                    </td><td>          </td><td>&nbsp;</td><td>&nbsp;</td>
		</tr><tr>
			<td>wzl2-4p   </td><td>
                         普通
                    </td><td>
                         阶段二
                    </td><td>
                     链表 
                    </td><td>若str是采用单链表存储的串，编写一个函数将其中的所有为c的字符替换为s字符</td><td>
                      &nbsp;若str是采用单链表存储的串，编写一个函数将其中的所有为c的字符替换为s字符  
                    </td><td>          </td><td>&nbsp;</td><td>&nbsp;</td>
		</tr><tr>
			<td>yjw-1-01-p</td><td>
                         普通
                    </td><td>
                         阶段二
                    </td><td>
                     链表 
                    </td><td>编写算法：统计出单链表HL中结点的值等于给定值X的结点数</td><td>
                     统计出单链表HL中结点的值等于给定值X的结点数。int CountX(LNode* HL,ElemType x)
                    </td><td>          </td><td>&nbsp;</td><td>&nbsp;</td>
		</tr><tr>
			<td>wzl-2-1p  </td><td>
                         普通
                    </td><td>
                         阶段二
                    </td><td>
                     链表 
                    </td><td>已知head是带头结点的单循环链表的头指针，</td><td>
                     已知head是带头结点的单循环链表的头指针，链表中的数据元素依次为a1,a2,a3..an；A为指向空的顺序表的指针，阅读以下程序段，并回答问题：(1)写出执行完程序段后，顺序表A中的数据元素：（2）写出程序段的功能if(head-&gt;next!=head){p=head-&gt;next;A-&gt;length=0;while(p-&gt;next!=head){p=p-&gt;next;A-&gt;data[A-&gt;length ++]=p-&gt;data; if(p-&gt;next!=head)p=p-&gt;next;}} 
                    </td><td>          </td><td>&nbsp;</td><td>&nbsp;</td>
		</tr><tr>
			<td>wzl-2-2p  </td><td>
                         普通
                    </td><td>
                         阶段二
                    </td><td>
                     链表 
                    </td><td>描述下列算法函数段的功能</td><td>
                      &nbsp;描述下列算法函数段的功能（head是带头结点的单链表）void abc(slink *head){ slink *p,*q; p=head-&gt;next; head-&gt;next=null; while(p!=null) { q=p-&gt;next; p-&gt;next=head-&gt;next; head-&gt;next=p; p=q; } Return head}  
                    </td><td>          </td><td>&nbsp;</td><td>&nbsp;</td>
		</tr><tr>
			<td>yjw-2-03-p</td><td>
                         普通
                    </td><td>
                         阶段二
                    </td><td>
                     链表 
                    </td><td>编写算法：在无头节点的单链表中实现删除第i个结点</td><td>
                     设计在无头结点的单链表中删除第i个结点的算法。
                    </td><td>          </td><td>&nbsp;</td><td>&nbsp;</td>
		</tr><tr>
			<td>yjw-2-04-p</td><td>
                         普通
                    </td><td>
                         阶段二
                    </td><td>
                     链表 
                    </td><td>编写算法：在单链表上实现线性表的求表长ListLength(L)运算</td><td>
                     在单链表上实现线性表的求表长ListLength(L)运算
                    </td><td>          </td><td>&nbsp;</td><td>&nbsp;</td>
		</tr><tr>
			<td>yjw-3-04-j</td><td>
                         简单
                    </td><td>
                         阶段三
                    </td><td>
                     栈和队列 
                    </td><td>写出结果：简述下述算法中各语句的主要作用，并写出算法的功能（栈和队列的元素类型均为int）。</td><td>
                     简述下述算法中各语句的主要作用，并写出算法的功能（栈和队列的元素类型均为int）。voidalgo(Queue &amp;Q){Stack S; int d;InitStack(S);while(!QueueEmpty(Q)){ DeQueue (Q,d); Push(S,d);};while(!StackEmpty(S)){ Pop(S,d); EnQueue (Q,d); }}
                    </td><td>          </td><td>&nbsp;</td><td>&nbsp;</td>
		</tr><tr>
			<td>wzl-2-3p  </td><td>
                         普通
                    </td><td>
                         阶段三
                    </td><td>
                     栈和队列 
                    </td><td>阅读下列算法，说明算法含义</td><td>
                      &nbsp;给出下列算法段的功能void Demo3( CirQueue *Q) {//循环队列，设DataType 为int 型 int x; SeqStack S;InitStack( &amp;S);while (! QueueEmpty( Q )){x=DeQueue( Q); Push( &amp;S,x);}while (! StackEmpty( &amp;s)){ x=Pop(&amp;S); EnQueue( Q,x );}}// Demo3 
                    </td><td>          </td><td>&nbsp;</td><td>&nbsp;</td>
		</tr><tr>
			<td>yjw-3-01-p</td><td>
                         普通
                    </td><td>
                         阶段三
                    </td><td>
                     栈和队列 
                    </td><td>写出结果：4辆列车顺序进入栈式结构车站，写出离开车站的所有可能顺序</td><td>
                     设有编号为1，2，3，4的四辆列车，顺序进入一个栈式结构的车站，具体写出这四辆列车开出车站的所有可能的顺序。
                    </td><td>          </td><td>&nbsp;</td><td>&nbsp;</td>
		</tr><tr>
			<td>yjw-3-02-p</td><td>
                         普通
                    </td><td>
                         阶段三
                    </td><td>
                     栈和队列 
                    </td><td>写出结果：简述下列程序段的功能</td><td>
                     void algo(Stack S, int k)void algo(Stack S, int k){int temp; &nbsp;Stack T; while (!empty(S)){temp = pop(S);if (temp != k) push(T, temp);}while (!empty(T)){temp = pop(T); push(S, temp);}}
                    </td><td>          </td><td>&nbsp;</td><td>&nbsp;</td>
		</tr><tr>
			<td>yjw-4-02-p</td><td>
                         普通
                    </td><td>
                         阶段四
                    </td><td>
                     
                    </td><td>编写算法：s和t是表示成单链表的两个串，找出s中第1个不在t中出现的字符</td><td>
                     设s和t是表示成单链表的两个串，试编写一个找出s中第1个不在t中出现的字符（假定每个结点只存放1个字符）的算法。
                    </td><td>          </td><td>&nbsp;</td><td>&nbsp;</td>
		</tr><tr>
			<td>yjw-5-05-p</td><td>
                         简单
                    </td><td>
                         阶段五
                    </td><td>
                     树和森林
                    </td><td>写出答案：根据树边的集合，写出下列问题的答案</td><td>
                     已知一棵树边的集合为{&lt;i，m&gt;，&lt;i，n&gt;，&lt;e，i&gt;，&lt;b，e&gt;，&lt;b，d&gt;，&lt;a，b&gt;，&lt;g，j&gt;，&lt;g，k&gt;，&lt;c，g&gt;，&lt;c，f&gt;，&lt;h，l&gt;，&lt;c，h&gt;，&lt;a，c&gt;}，请在草稿纸上画出这棵树，写出下列问题的答案：（1）哪个是根结点？（2）哪些是叶子结点？（3）哪个是结点g的双亲？（4）哪些是结点g的祖先？（5）哪些是结点g的孩子？（6）树的深度是多少？（7）哪些是结点e的兄弟？（8）结点b和n的层次号分别是什么？
                    </td><td>(1)   a
(2)m n d l f  j k 
(3)c
(4)c a
(5)j k 
(6)5
(7)d
(8) 2 5</td><td>&nbsp;</td><td>&nbsp;</td>
		</tr><tr>
			<td>yjw-5-02-p</td><td>
                         普通
                    </td><td>
                         阶段五
                    </td><td>
                     遍历二叉树
                    </td><td>编写算法：统计一棵二叉树的叶子节点数目</td><td>
                     编写算法：统计一棵二叉树的叶子节点数目。
                    </td><td>          左子树叶子结点
右子树叶子结点
左右子树叶子结合之和</td><td>&nbsp;</td><td>&nbsp;</td>
		</tr><tr>
			<td>yjw-5-03-p</td><td>
                         普通
                    </td><td>
                         阶段五
                    </td><td>
                     二叉树
                    </td><td>编写算法：求二叉树的深度</td><td>
                     写出求二叉树深度的算法。
                    </td><td>          思路：
左子树深度
右子树深度
max（左，右深度）+1</td><td>&nbsp;</td><td>&nbsp;</td>
		</tr><tr>
			<td>yjw-5-06-p</td><td>
                         简单
                    </td><td>
                         阶段五
                    </td><td>
                     遍历二叉树
                    </td><td>写出结果：已知二叉树的先序遍历、中序遍历，请写出后序遍历</td><td>
                     假设一棵二叉树的先序序列为EBADCFHGIKJ，中序序列为ABCDEFGHIJK，请写出该二叉树的后序遍历序列。
                    </td><td>          </td><td>&nbsp;</td><td>&nbsp;</td>
		</tr><tr>
			<td>yjw-5-08-p</td><td>
                         普通
                    </td><td>
                         阶段五
                    </td><td>
                     遍历二叉树
                    </td><td>写出结果：已知二叉树的后序遍历、中序遍历，请写出先序遍历</td><td>
                     假设一棵二叉树的后序序列为DCEGBFHKJIA，中序序列为DCBGEAHFIJK，请写出该二叉树的先序遍历序列.
                    </td><td>          </td><td>&nbsp;</td><td>&nbsp;</td>
		</tr><tr>
			<td>yjw-5-01-p</td><td>
                         普通
                    </td><td>
                         阶段五
                    </td><td>
                     遍历二叉树
                    </td><td>编写算法：求一棵二叉树中结点的总数</td><td>
                     编写求一棵二叉树中结点总数的算法。遍历方式自选（前序、中序、后序遍历）
                    </td><td>          遍历每个结点，每遍历一个结点计数器+1</td><td>&nbsp;</td><td>&nbsp;</td>
		</tr><tr>
			<td>yjw-5-04-p</td><td>
                         普通
                    </td><td>
                         阶段五
                    </td><td>
                     二叉树
                    </td><td>写出结果：简述下述算法中各语句的主要作用，并写出算法的功能</td><td>
                     简述下述算法中各语句的主要作用，并写出算法的功能struct BTreeNode{ &nbsp;elemtype data; &nbsp;struct BTreeNode *lchild; &nbsp;struct BTreeNode *rchild;};int hight(BTreeNode T){ int h1,h2,h; &nbsp;if (T= =null) &nbsp; &nbsp;return(0); &nbsp;else{ &nbsp; &nbsp;h1=hight(T-&gt;lchild); &nbsp; &nbsp; &nbsp;h2=hight(T-&gt;rchild);  &nbsp; &nbsp;if(h1&gt;=h2) &nbsp; &nbsp; &nbsp;h=h1+1; &nbsp; &nbsp; &nbsp; &nbsp;else &nbsp; &nbsp; &nbsp;h=h2+1; &nbsp; &nbsp;return(h) &nbsp;}}
                    </td><td>求二叉链表存储的二叉树的深度（高度）。</td><td>&nbsp;</td><td>&nbsp;</td>
		</tr><tr>
			<td>wzl-06-1-1p</td><td>
                         普通
                    </td><td>
                         阶段六
                    </td><td>
                     图综合
                    </td><td>求从下图v0开始到其他各点的最短路径</td><td>
                     求从下图v0开始到其他各点的最短路径（请写出每次的选择步骤，可以不画表，列出即可；要写出v0到其他顶点的路径及路径长度）
                    </td><td>          </td><td>&nbsp;</td><td>&nbsp;</td>
		</tr><tr>
			<td>wzl-06-2-2p</td><td>
                         普通
                    </td><td>
                         阶段六
                    </td><td>
                     图综合
                    </td><td>写出下图所有拓扑排序序列</td><td>
                     画出左图的邻接矩阵（不要以图片形式，直接在答案框内画，并按邻接矩阵，写出左图中拓扑排序序列
                    </td><td>          </td><td>&nbsp;</td><td>&nbsp;</td>
		</tr><tr>
			<td>yjw-6-01-p</td><td>
                         普通
                    </td><td>
                         阶段六
                    </td><td>
                     图综合
                    </td><td>写出结果：写出下图所有的拓扑序列</td><td>
                     已知有向图如下所示，请写出该图所有的拓扑序列.（用顶点表示）
                    </td><td>          </td><td>&nbsp;</td><td>&nbsp;</td>
		</tr><tr>
			<td>yjw-6-07-p</td><td>
                         普通
                    </td><td>
                         阶段六
                    </td><td>
                     图的遍历
                    </td><td>写出结果：已知一个有向图，分别写出从顶点0出发按深度优先搜索和广度优先搜索遍历得到的顶点序列。</td><td>
                     对于一个有向图，假定采用邻接表表示，并且假定每个顶点单链表中的边结点是按出边邻接点序号从大到小的次序链接的，试分别写出从顶点0出发按深度优先搜索遍历得到的顶点序列和按广度优先搜索遍历得到的顶点序列。
                    </td><td>          </td><td>&nbsp;</td><td>&nbsp;</td>
		</tr><tr>
			<td>yjw-6-06-p</td><td>
                         普通
                    </td><td>
                         阶段六
                    </td><td>
                     图的遍历
                    </td><td>写出结果：已知某无向图的邻接矩阵，写出从顶点0出发，进行深度优先和广度优先搜索遍历的顶点序列</td><td>
                     已知一个无向图的邻接矩阵如图所示，试写出从顶点0出发分别进行深度优先和广度优先搜索遍历得到的顶点序列。
                    </td><td>          </td><td>&nbsp;</td><td>&nbsp;</td>
		</tr><tr>
			<td>yjw-6-03-p</td><td>
                         普通
                    </td><td>
                         阶段六
                    </td><td>
                     图的应用
                    </td><td>写出结果：使用最短路径算法，求下图中a到z的最短路径</td><td>
                     只需写出a-z最短路径，不必写出过程。
                    </td><td>          </td><td>&nbsp;</td><td>&nbsp;</td>
		</tr><tr>
			<td>yjw-6-02-k</td><td>
                         困难
                    </td><td>
                         阶段六
                    </td><td>
                     图综合
                    </td><td>写出结果：图的综合题，写出算法的结果和时间复杂度</td><td>
                     设如下图所示的二叉树B的存储结构为二叉链表，root为根指针，结点结构为：（lchild,data,rchild）。其中lchild，rchild分别为指向左右孩子的指针，data为字符型，root为根指针，试回答下列问题：1.对下列二叉树B，执行下列算法traversal(root)，试指出其输出结果；2.假定二叉树B共有n个结点，试分析算法traversal(root)的时间复杂度。
                    </td><td>          </td><td>&nbsp;</td><td>&nbsp;</td>
		</tr><tr>
			<td>yjw-6-04-p</td><td>
                         普通
                    </td><td>
                         阶段六
                    </td><td>
                     图的应用
                    </td><td>写出结果：AOE网如下，求关键路径</td><td>
                     如图给出了一个具有15个活动、11个事件的工程的AOE网，求关键路径。（事件表示、活动表示均可）
                    </td><td>v1 v2 v3 v4 v5 v6 v7 v8 v9 v10 v11
0  3  4  5  7  9  15 11 21 22  28
0  6  4  15 7  19 21 11 21 22  28</td><td>&nbsp;</td><td>&nbsp;</td>
		</tr><tr>
			<td>yjw-7-01-p</td><td>
                         普通
                    </td><td>
                         阶段七
                    </td><td>
                     哈希表
                    </td><td>写出结果：根据哈希函数，求出平均查找长度ASLsucc和ASLunsucc</td><td>
                      设哈希函数H（k）=3K mod 11，散列地址空间为0～10，对关键字序列（32,13,49,24,38,21,4,12）按线性探测再散列解决冲突的方法构造哈希表。哈希表不必画出，但要求分别求出等概率下查找成功时和查找失败时的平均查找长度ASLsucc和ASLunsucc。
                    </td><td>          </td><td>&nbsp;</td><td>&nbsp;</td>
		</tr><tr>
			<td>yjw-8-01-j</td><td>
                         简单
                    </td><td>
                         阶段八
                    </td><td>
                     
                    </td><td>写出结果：写出直接插入排序每一趟的结果</td><td>
                     写出用直接插入排序将关键字序列{54,23,89,48,64,50,25,90,34}排序过程的每一趟结果。
                    </td><td>          </td><td>&nbsp;</td><td>&nbsp;</td>
		</tr><tr>
			<td>yjw-8-02-p</td><td>
                         普通
                    </td><td>
                         阶段八
                    </td><td>
                     
                    </td><td>写出结果：写出希尔排序每一趟的结果</td><td>
                     设待排序序列为{10,18,4,3,6,12,1,9,15,8}请写出希尔排序每一趟的结果。增量序列为5，3，2，1。
                    </td><td>          </td><td>&nbsp;</td><td>&nbsp;</td>
		</tr><tr>
			<td>yjw-8-03-k</td><td>
                         困难
                    </td><td>
                         阶段八
                    </td><td>
                     
                    </td><td>编写算法：实现一个双向起泡的排序算法，即相邻两趟向相反方向起泡。</td><td>
                     编写一个双向起泡的排序算法，即相邻两趟向相反方向起泡。
                    </td><td>          </td><td>&nbsp;</td><td>&nbsp;</td>
		</tr><tr>
			<td>yjw-8-05-p</td><td>
                         普通
                    </td><td>
                         阶段八
                    </td><td>
                     
                    </td><td>写出结果：写出堆排序的结果</td><td>
                     已知一组记录为(46,74,53,14,26,38,86,65,27,34)，写出建堆和堆排序的结果。
                    </td><td>          </td><td>&nbsp;</td><td>&nbsp;</td>
		</tr><tr>
			<td>yjw-8-04-j</td><td>
                         简单
                    </td><td>
                         阶段八
                    </td><td>
                     
                    </td><td>写出结果：写出冒泡排序每一趟排序的结果。</td><td>
                     已知一组记录为(46,74,53,14,26,38,86,65,27,34)，给出采用冒泡排序法进行排序时每一趟的排序结果。
                    </td><td>46,53,14,26,38,74,65,27,34,86
46,14,26,38,53,65,27,34,74,86
14,26,38,46,53,27,34,65,74,86
14,26,38,46,27,34,53,65,74,86
14,26,38,27,34,46,53,65,74,86
14,26,27,34,38,46,53,65,74,86</td><td>&nbsp;</td><td>&nbsp;</td>
		</tr><tr>
			<td>yjw-5-07-p</td><td>
                         普通
                    </td><td>
                         阶段九
                    </td><td>
                     广义表
                    </td><td>写出结果：根据题目给出的树，回答问题。</td><td>
                     一棵深度为H的满k叉树有如下性质：第H层上的结点都是叶子结点，其余各层上每个结点都有k棵非空子树，如果按层次自上至下，从左到右顺序从1开始对全部结点编号，回答下列问题：（1）各层的结点数目是多少？（2）编号为n的结点的父结点如果存在，编号是多少？（3）编号为n的结点的第i个孩子结点如果存在，编号是多少？（4）编号为n的结点有右兄弟的条件是什么？其右兄弟的编号是多少？
                    </td><td>          </td><td>&nbsp;</td><td>&nbsp;</td>
		</tr>
	</table>
</div></form>