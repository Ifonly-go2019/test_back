stackflow github


条件运算符的结合顺序从右往左
 x > y ? printf("1") : (c==0) ? printf("2") : printf("3"); //本行遵循从右往左的顺序来结合
    //先把 ( c == 0) ? printf("2") : printf("3") 当作一个整体
    //再把 ( x>y? printf("1") : ( c == 0 ) ? printf("2") : printf("3"));当作一个整体


if else就近原则

fflush
scanf之间清理缓存

!!!!!getchar() getch()

GETCHAR 和 GETCH 基本功能相同，差e是后者直接从键盘获取键值，不等待用户按回车，只要用户输入一个键，它立刻返回，返回值是用户输入的ASCLL码
出错返回-1，输入的字符不会回显在屏幕上 
!!sprintf 把一个内容以某种格式打印（赋值）到字符数组里面
//sprintf(ch2, "%daadd", n2); 将%daadd 赋值给字符串ch2
break跳一层
c必须在开始前定义变量

判断换行时，换行计数器必须紧贴换行整除值
// cn++
if（cn%5==0）
printf("\n")

取余

水仙花数
一个三位数，各个位数的数字的立方和等于该三位数的值

pow(变量，次方)；

静态数组在运行之前就要规定

 [栈 堆 常量 代码]

栈区
羽毛球桶 一个一个加入 一个一个取出 调用完后会删除栈中的内容
数组的名字=内存地址=数组第0个元素的内存地址
打印时不用加入寻址码
// char str[100]="hello"           /*100表示分配100字节*/!!!!!!预留空间一定要足够大，防止越界
printf("%s",str) 打印hello
printf("%s"，&str[2]) 打印llo

for循环强制打印字符数组内的内容
#include <stdio.h>

int main(void)
{
	char c[10] = "ch\0ina";
	int i;

	/*scanf("%s", c);*/
	for (i = 0; i < 10; i++)
	{
		printf("%c  ", c[i]);
	}
	printf("\n%s", c);

	return 0;
}

冒泡排序练习	

！！！使用数组和定义数组之间下标的区别

字符数组和字符串的区别
字符串是特殊的字符数组
字符串以空字符即\0

gets 能识别空格 scanf不能 


功能独立且常使用的语句可以定义为函数调用
一般来说子函数写在前面，main函数写在后面 、
若函数的定义在后面，则在MAIN函数中要首先声明函数
int main(void)
{        
        int isprime(int n);//！！！！函数的声明，n 可以省略 只需告知需要一个整数即可
	int m, n = 0;

	for (m = 100; m < 200; m++)
	{
		if (isprime(m) == 1)
		{
			printf("%5d", m);
			n++;
			if (n % 10 == 0)
			{
				printf("\n");
			}
		}
	}
	return 0;
}


        int isprime(int n)
     {
	int i;
	for (i = 2; i <= n / 2; i++)
	{
		if (n % i == 0)
			return 0;
		}
	}
		{
	return 1;
       }


函数的定义是平行的
函数的嵌套定义在c中不被允许

系统的文件用<>扩起来，vc会在安装目录中寻找，并把相应文件的代码替换至此函数
如 <stdio.h>  


实际参数将值！！！传递给形式参数，形式参数再以此使用 值相等 
函数返回值从被调函数返回给主调函数

如 数据的录入应该是在main函数中进行（scanf gets） 再传递给子函数，子函数运行后返回一个值给主函数

实际上 函数名自己可以就是一个地址



c语言需要在执行代码之前就要定义局部变量
c++则无此问题

形参和实参在栈区有不同的内存位置，通常来说是实参的值copy（值传递）给形参。之后新定义的函数内的形参的值的改变与实参无关
 rand怎么生成随机数 

值传递与地址传递
//值传递 先copy再赋值 形参改变 实参不变 //地址传递 将地址（地址中存有数据）存到实参（不为实际数据）中，再传给形参 形参（（*x）++）改变 实参改变

多文件.c怎么在一起使用？？？？

函数的栈区中的返回地址 上一个函数执行完后把值返回到返回到返回地址，随后栈区消去这层函数

递归函数 不断调用自己 等到最后一次调用后 栈释放 回到上一层

指针 第二级或第三级 调用的是第一级的数据的地址
地址加减 *x1-- （x1为a的地址 a=10） a=9

子函数中数据的传出可以用地址的方法 即一级指针的用法

全局变量 函数之外定义的变量 存在常量区 函数内定义的变量只能在函数内使用

二维数组 （int （*arry）[4]，int row） 二维数组后定义一维数组的地址 *arry为数组指针 row为行数 
详情参考code L7.7.41

赋值式 等号右边理解为一个值 等号左边理解为一个框（将值填入这个框）
//int i=1,k=2,*p;

p=&k;

*p=i;


指针的类型取决于指向的类容的内容 定义指针的时候要加*号 指针变量自身占4个字节

int*q=p 左边的指针指向右边指针所指向的东西列指针
动态数组与静态数组的区别

二维数组的首地址=第0行的地址
在同一数组中 p1-p2 等于两者间元素个数的差
个指针运算以单个元素运算，行指针以行运算
数组加一个整数后还是地址
二维数组中：
*（a+i）为数组第i行的数组名=第i行地址值
*（a+i）+j 为列指针=第i行第j列的地址值 已经固定在第i行
*（*（a+i）+j)为第i行j列的元素值

在给指针赋值之前，必须给指针申请一个有效的空间
char *p; scanf("%s",p) 错误 录入的数据会被送到乱码指向的空间
char str[8], *p=str; scanf("%s",p) 正确 指针已初始化 会被送到正确的空间


定义函数 int max（int int） 可以同时定义以一个指针（*p）（a，b）  调用函数的时候可以使用
函数名max（a，b） 也可使用指针（*p）（a，b）

指针数组 类型* 数组名[数组长度];
数组指针 
函数指针 
指针函数


二重指针 类型**指针变量名 //**pp++先用在+   *pp=p的值=a的地址  **pp=a的值


在命令行中打开c文件 可以同时传入参数 例如L8.7.3
其中 int argc 打印之后 argc计算了打开文件这个命令本身的次数

malloc命令在堆区中申请空间
 void * malloc(unsigned int size)
    （malloc出来的空间，操作系统有一张表来记录）
   （调用此命令之后要判断是否成功执行，与内存交互极易出错）
    (返回不含类型信息的地址)
   （需要malloc.h或stdlib.h）
free命令释放了申请的空间
  void free(void *p)
  （需要一个地址）
 （不需要任何返回值）
 (需要malloc.h或stdlib.h)

环境变量 


结构体
多个不同类型的数据组合在一起表达了某种事务的属性
声明一个结构体类型：
struct 结构体类型名
	{成员列表}；
其中成员列表都应进行类型声明：
类型名   成员名；（成员可以包含基础类型 指针类型 以及结构体类型）
(类型名称推荐大写 变量名称推荐小写)
（成员名可以与程序中的变量名相同）
结构体声明后，相当于用户自己定义了一种数据类型（不分配内存空间）

结构体类型=struct+自定义类型名


  
先声明结构体类型，再定义结构体类的变量  struct student{...};
                                   struct student s1,s2;

在声明类型的同时定义变量         struct student
                                 {...} s1,s2;
                                struct student s3;
 
直接定义结构体类型变量      struct {...} s1,s2

引用方式：
结构体变量名.成员名
  st1.num,    st1.birthday.month

引用规则：
结构体变量不能整体进行输入和输出
成员也是结构体时，找最底层的成员
结构体变量成员与普通变量用法相同st1.age++;
可以取结构体变量成员的地址，也可以取结构体变量的地址


结构体的假拷贝

